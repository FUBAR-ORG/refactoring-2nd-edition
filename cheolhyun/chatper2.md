# Chapter 02 - 리팩터링 원칙

## 2.1 리팩터링 정의

**리팩터링**은 두리뭉실한 의미로 통용되며, 명사로도 쓰일 수 있고 동사로도 쓰일 수 있다

> 리팩터링: [명사] 소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법
> > 함수 추출하기, 조건부 로직을 다형성으로 바꾸기

> 리팩터링: [동사] 소프트트웨어의 겉보기 동작은 그대로 유지한 채, 여러가지 리팩터링 기법을 적용해서 소프트웨어를 재구성하다.

특정한 방식에 따라 코드를 정리하는 것만이 리팩터링이다  
리팩터링은 결국 동작을 보존하는 작은 단계들을 거쳐 코드를 수정하고, 이러한 단계들을 순차적으로 연결하여 큰 변화를 만들어내는 일이다  
따라서 리팩터링하는 동안에는 코드가 항상 정상 작동하기 때문에 전체 작업이 끝나지 않았더라도 언제든 멈출 수 있다

> 누군가 "리팩터링하다가 코드가 깨져서 며칠이나 고생했다"라고 한다면, 십중팔구 리팩터링한 것이 아니다.

코드베이스를 정리하거나 구조를 바꾸는 모든 작업을 **재구성(restructuring)**이라는 포괄적인 용어로 표현하고, 리팩터링은 재구성의 한 형태

리팩터링은 겉보기 동작을 동일하게 유지하기 때문에 내부적인 성능의 변화는 있을 수 있고, 모듈의 인터페이스가 변경될 수도 있다  
리팩터링 과정 중 발견된 버그는 리팩터링 후에도 남아 있어야 한다(아무도 모르는 숨은 버그는 수정해도 괜찮다)

리팩터링은 성능 최적화와 유사하게 코드를 변경하지만 프로그램의 전반적인 기능은 그대로 유지한다  
단지 목적이 다를 뿐이다

> 성능 최적화는 프로그램의 특정 부분을 더 빠르게 만드는 것이 목적이다  
> 목표 성능에 반드시 도달해야 한다면 코드는 다루기 더 어려워질 수 있음을 각오해야 한다

---

## 2.2 두 개의 모자

소프트웨어를 개발할 때 목적이 '기능 추가'냐, 아니면 '리팩터링'이냐를 명확히 구분해 작업한다  
이 두 가지 목적을 동시에 수행하면 안된다  
기능 추가에서는 테스트를 작성하여 통과하는지 확인만 하고 리팩터링에서는 기능 추가를 하지 않고, 동시에 테스트도 추가하지 않는다  
부득이하게 인터페이스를 변경해야 할 때만 기존 테스트를 수정한다

항상 내가 어떤 작업을 하고 있는지와 그에 따른 미묘한 작업 방식의 차이를 분명하게 인식해야 한다

---

## 2.3 리팩터링하는 이유

### 리팩터링하면 소프트웨어 설계가 좋아진다

리팩터링하지 않으면 소프트웨어의 내부 설계(아키텍처)가 썩기 쉽다  
아키텍처를 이해하지 못한 채 단기 목표만을 위해 코드를 수정하다 보면 기반 구조가 무너지기 쉽다  
그렇게 코드만 봐서는 설계를 파악하기 어려워진다

> 규칙적인 리팩터링은 코드의 구조를 지탱해줄 것이다

중복 코드 제거는 설계 개선 작업의 중요한 한 축을 차지한다  
코드량이 줄어들면 수정하는 데 드는 노력은 크게 달라진다  
이해해야할 코드량도 줄어들고 실수 없이 수정하기 쉬워지며 동작을 예상하기 쉽다

> 중복 코드를 제거하면 모든 코드가 언제나 고유한 일을 수행함을 보장할 수 있으며, 이는 바람직한 설계의 핵심

### 리팩터링하면 소프트웨어를 이해하기 쉬워진다

프로그래밍은 컴퓨터와 대화하는 것과 유사하지만, 내 소스 코드를 컴퓨터만 사용하는 것이 아니다  
몇 달이 지나 누군가 내 코드를 수정하고자 읽을 대, 코드를 이해하기 어렵다면 시간에 지연이 발생할 것이다

프로그램을 동작시키는 데만 신경 쓰다 보면 나중에 그 코드를 다룰 개발자를 배려하지 못한다는 데 있다  
코드를 이해하기 쉽게 만들려면 일하는 리듬에 변화를 줘야 한다

리팩터링은 코드가 더 잘 읽히게 도와준다

다른 사람이 곧 내가 될 수 있기 때문에 리팩터링은 더더욱 중요하다

기억할 필요가 있는 것들은 최대한 코드에 담으려 한다

### 리팩터링하면 버그를 쉽게 찾을 수 있다

코드를 이해하기 쉽다는 말은 버그를 찾기 쉽다는 말이기도 하다  
리팩터링 과정에 "이럴 것이다"라고 가정하던 점들이 분명히 드러나는데, 버그를 지나치려야 지나칠 수 없을 정도까지 명확해진다

> "난 뛰어난 프로그래머가 아니에요. 단지 뛰어난 습관을 지닌 괜찮은 프로그래머일 뿐이에요."

### 리팩터링하면 프로그래밍 속도를 높일 수 있다

새로운 기능을 추가할수록 기존 코드베이스에 잘 녹여낼 방법을 찾는 데 드는 시간이 늘어난다

프로그래밍 속도는 소프트웨어 내부 품질에 따라 달라질 수 있다  
내부 설계가 잘 된 소프트웨어는 새로운 기능을 추가할 지점과 어떻게 고칠지를 쉽게 찾을 수 있다

모듈화가 잘 되어 있으면 전체 코드베이스 중 작은 일부만 이해하면 된다  
코드가 명확하면 버그를 만들 가능성도 줄고, 버그를 만들더라도 디버깅하기가 훨씬 쉽다

내부 품질이 뛰어난 코드베이스는 새 기능 구축을 돕는 견고한 토대가 된다

#### 지구력 가설(Design stamina Hypothesis)

내부 설계에 심혈을 기울이면 소프트웨어의 지구력이 높아져서 빠르게 개발할 수 있는 상태를 더 오래 지속할 수 있다

> 처음부터 좋은 설계를 마련하기란 매우 어렵다  
> 그래서 빠른 개발이라는 숭고한 목표를 달성하려면 리팩터링이 반드시 필요하다

---

## 2.4 언제 리팩터링해야 할까?

> 필자는 프로그래밍할 때 거의 한 시간 간격으로 리팩터링 한다

### 3의 법칙(돈 로버츠, Don Roberts)

1. 처음에는 그냥 한다.
2. 비슷한 일을 두 번째로 하게 되면(중복이 생겼다는 사실에 당황스럽겠지만), 일단 계속 진행한다.
3. 비슷한 일을 세 번째 하게 되면 리팩터링한다.

> 스트라이크 세 번이면 리팩터링(삼진 리팩터링)

### 준비를 위한 리팩터링: 기능을 쉽게 추가하게 만들기

리팩터링하기 가장 좋은 시점은 코드베이스에 기능을 새로 추가하기 직전이다  
이 시점에서 현재 코드를 살펴보면서, 구조를 살짝 바꾸면 다른 작업을 하기가 훨씬 쉬워질 만한 부분을 찾는다

- 기존의 함수가 새로운 요구사항을 거의 만족하지만 리터럴 값 몇 개가 방해되는 함수가 있다
- 함수를 복제해서 해당 값만 수정해도 되지만 중복 코드가 발생한다
  - 나중에 이 부분을 변경할 일이 생기면 원래 코드가 복사한 코드를 모두 수정해야 한다
  - 더 심한 경우는 복제한 코드가 어디 있는지까지 일일이 찾아내야 한다
  - 나중에 새 기능을 약간 변형한 버전을 만들어야 할 때 번거로울 수 있다
- 이럴 때 **함수 매개변수화하기**를 적용할 수 있다

> 다들 "직진!"이라고 외칠 때 "잠깐, 지도를 보고 가장 빠른 경로를 찾아보자"라고 말할 줄 아는 것이 준비를 위한 리팩터링이다

버그를 잡을 때도 마찬가지이다

오류를 일으키는 코드가 세 곳에 복제되어 퍼져 있다면, 우선 한 곳으로 합치는 편이 작업하기에 훨씬 편하다  
또는 질의 코드에 섞여 있는 갱신 로직을 분리하면 두 작업이 꼬여서 생기는 오류를 크게 줄일 수 있다

> 준비를 위한 리팩터링(Preparatory Refactoring)으로 상황을 개선해놓으면 버그가 수정된 상태가 오래 지속될 가능성을 높이는 동시에, 같은 곳에서 다른 버그가 발생할 가능성을 줄일 수도 있다

### 이해를 위한 리팩터링: 코드를 이해하기 쉽게 만들기

코드를 수정하려면 먼저 그 코드가 하는 일을 파악해야 한다  
코드를 파악할 때마다 그 코드의 의도가 더 명확하게 드러나도록 리팩터링할 여지는 없는지 찾아본다

리팩터링하면 머리로 이해한 것을 코드에 옮겨담을 수 있고, 수정한 코드를 테스트해보면 내 생각이 맞았는지 확인할 수 있다

코드를 분석할 때 리팩터링을 해보면, 그렇지 않았더라면 도달하지 못했을 더 깊은 수준까지 이해하게 된다

### 쓰레기 줍기 리팩터링

리팩터링의 필요가 있는 코드를 봤을 때 급한 일에 의해서 당장 처리를 못하더라도 조금이나마 개선해두는 것이 좋다

> 항상 처음 봤을 때보다 깔끔하게 정리하고 떠나자.

### 계획된 리팩터링과 수시로 하는 리팩터링

앞선 리팩터링은 모두 기회가 될 때만 진행한다  
리팩터링 일정을 따로 잡아두지 않고, 기능을 추가하거나 버그를 잡는 동안 리팩터링도 함께 한다 즉, 프로그래밍 과정에 자연스럽게 녹인 것이다

리팩터링은 프로그래밍과 구분되는 별개의 활동이 아니다  
마치 프로그래밍할 때 `if` 문 작성 시간을 따로 구분하지 않는 것과 같다

> 보기 싫은 코드를 발견하면 리팩터링하자. 그런데 잘 작성된 코드 역시 수많은 리팩터링을 거쳐야 한다.

> 무언가 수정하려 할 때는 먼저 수정하기 쉽게 정돈하고 쉽게 수정하자.

리팩터링에 소홀했다면, 따로 시간을 내서 새 기능을 추가하기 쉽도록 코드베이스를 개선할 필요가 있다

계획된 리팩터링은 예상치 못한 상황에 대응하기 어렵기 때문에 최소한으로 줄여야 한다

### 오래 걸리는 리팩터링

리팩터링의 규모가 커질 수 있지만 이 경우에도 팀 전체가 리팩터링에 매달리는 것은 좋지 않은 것 같다  
주어진 문제를 몇 주에 걸쳐 조금씩 해결해가는 편이 효과적일 때가 많다

- 라이브러리를 교체할 때는 기존 것과 새 것 모두를 포용하는 추상 인터페이스부터 마련한다
- 기존 코드가 이 추상 인터페이스를 호출하도록 만들고 나면 라이브러리를 훨씬 쉽게 고칠 수 있다
- > 이 전략을 추상화로 갈아타기(Branch By Abstraction)라 한다

### 코드 리뷰에 리팩터링 활용하기

코드 리뷰는 개발팀 전체에 지식을 전파하는 데 좋다

- 노하우 전수
- 대규모 소프트웨어 시스템의 다양한 측면을 더 많은 사람이 이해
- 깔끔한 코드 작성
- 다른 사람의 아이디어 전달

리팩터링은 다른 이의 코드를 리뷰하는 데도 도움된다

리팩터링은 코드 리뷰의 결과를 더 구체적으로 도출하는 데에도 도움된다  
개선안들을 제시하는 데서 그치지 않고, 그중 상당수를 즉시 구현해볼 수 있기 때문이다

풀 리퀘스트 모델은 코드 리뷰에 리팩터링을 접목하는 방법에는 그리 효과적이지 않다  
코드 작성자가 참석해야 맥락을 설명해줄 수 있고 작성자도 리뷰어의 변경 의도를 제대로 이해할 수 있으므로, 이왕이면 참석자가 참석하는 방식이 좋다

> 작성자와 나란히 앉아서 코드를 훑어가며 리팩터링하면 자연스럽게 짝 프로그래밍(pair programming)이 된다

### 관리자에게는 뭐라고 말해야 할까?

- 프로 개발자의 역할: 효과적인 소프트웨어를 최대한 빨리 만드는 것이다
- 프로 개발자에게 주어진 임무: 새로운 기능을 빠르게 구현하는 것이고, 가장 빠른 방법은 리팩터링이다

그래서 리팩터링부터 한다

### 리팩터링하지 말아야 할 때

1. 지저분한 코드를 발견해도 굳이 수정할 필요가 없다면 리팩터링하지 않는다  
   외부 `API` 다루듯 호출해서 쓰는 코드라면 지저분해도 그냥 둔다  
   내부 동작을 이해해야 할 시점에 리팩터링해야 효과를 제대로 볼 수 있다
2. 리팩터링하는 것보다 처음부터 새로 작성하는 게 쉬울 때도 리팩터링하지 않는다

---

## 2.5 리팩터링 시 고려해야 할 문제

무언가 언제 어디에 적용할지 판단하려면 손익을 제대로 이해해야 한다

리팩터링에 딸려 오는 문제도 엄연히 있기에, 이런 문제가 언제 발생하고 어떻게 대처해야 할지를 반드시 알고 있어야 한다

### 새 기능 개발 속도 저하

> 리팩터링의 궁극적인 목적은 개발 속도를 높여서, 더 적은 노력으로 더 많은 가치를 창출하는 것이다

그렇더라도 상황에 맞게 조율해야 한다

대부분은 리팩터링을 더 자주 하도록 노력해야 한다  
리더는 리팩터링의 필요성과 리팩터링 상황 판단 능력을 빠르게 갖추도록 개발 과정에서 많이 이끌어줘야 한다

리팩터링을 클린 코드(clean code)나 바람직한 엔지니어링 습관처럼 도덕적인 이유로 정당화하는 것이 가장 쉽게 빠지기 쉬운 오류이다  
리팩터링의 본질은 코드베이스를 예쁘게 꾸미는 것이 아니라, 경제적인 이유로 하는 것이다

### 코드 소유권

리팩터링하다 보면 모듈의 내부뿐 아니라 시스템의 다른 부분과 연동하는 방식에도 영향을 주는 경우가 많다  
리팩터링이 영향을 주는 코드의 소유자가 다른 팀이라서 쓰기 권한이 없을 수도 있다

리팩터링을 할 수 없는 것은 아니기 때문에, 기존 함수도 그대로 유지하며 기존 함수를 폐기 대상(deprecated)으로 표시한다

코드 소유권을 작은 단위로 나눠 엄격히 관리하면 오히려 인터페이스를 관리하느라 시달리는 결과를 초래할 수 있다

> 대규모 시스템에서는 오픈소스 개발 모델을 권장하기도 한다

### 브랜치

현재 가장 대중적으로 사용하는 [`Git Flow`](https://tecoble.techcourse.co.kr/post/2021-07-15-git-branch/)와 같은 전략은 독립 브랜치로 작업하는 기간이 길어질수록 `master` 브랜치로 통합하기 어려워진다는 단점이 있다  
그 고통을 줄이고자 마스터를 개인 브랜치에 수시로 리베이스하거나 머지한다  
하지만 여러 기능 브랜치에서 동시에 개발이 진행될 때는 이런 식으로 해결할 수 없다

머지와 통합을 명확히 구분한다

- 마스터를 브랜치로 머지하는 작업: 단방향
- 통합(마스터를 개인 브랜치로 풀 -> 작업한 결과를 다시 마스터에 푸시): 양방향

누군가 개인 브랜치에서 작업한 내용을 마스터에 통합하기 전까지는 그 내용을 볼 수 없다  
통합한 뒤에는 마스터에서 달라진 내용을 내 브랜치에서 머지해야 하는데, 그러려면 상당한 노력이 들 수 있다

이에 기능별 브랜치의 통합 주기를 2~3일 단위로 짧게 관리해야 한다고 주장하는 **지속적 통합**(`CI`, Continuous Integration)
, 또는 **트렁크 기반 개발**(`TBD`, Trunk-Based Development)이라 한다

`CI`에 따르면 모든 팀원이 하루에 최소 한 번은 마스터와 통합한다

- `CI`를 적용하기 위해서 치러야 할 대가
  - 마스터를 건강하게 유지
  - 거대한 기능을 잘게 쪼개는 법
  - 각 기능을 끌 수 있는 기능 토글(기능 플래그) 적용

`CI`는 리팩터링과 궁합이 아주 좋다  
리팩터링은 코드 전반적인 수정을 가할 때가 많으므로 머지 과정에서 충돌이 생길 위험이 크다

`CI`와 리팩터링을 합쳐서 **익스트림 프로그래밍**(`XP`, eXtreme Programming) 기법이 탄생했다

> 기능별 브랜치를 사용하지 말자는 것이 아니라, 브랜치를 자주 통합하여 문제가 발생할 가능성을 줄인다는 것이다  
> 통합 주기만큼은 최대한 짧게 잡아야 한다

> `CI`를 적용하는 편이 소프트웨어를 배포하는 데 훨씬 효과적이라는 객관적인 증거가 있다

### 테스팅

리팩터링의 단위 핵심은 오류를 재빨리 잡는 데 있으며, 이렇게 하려면 코드의 다양한 측면을 검사하는 테스트 스위트(test suite)가 필요하다  
달리 말하면 리팩터링하기 위해서는 자가 테스트 코드(self-testing code)를 마련해야 한다는 뜻이다

자가 테스트 코드는 리팩터링을 할 수 있게 해줄 뿐만 아니라, 새 기능 추가의 안정성을 높여준다  
테스트가 실패한다면 가장 최근에 통과한 버전에서 무엇이 달라졌는지 살펴볼 수 있다

자가 테스트 코드는 통합 과정에서 발생하는 의미 충돌을 잡는 메커니즘으로 활용할 수 있어서 자연스럽게 `CI`와도 밀접하게 연관된다  
`CI`에 통합된 테스트는 `XP`의 권장사항이자 지속적 배포(`CD`, Continuous Delivery)의 핵심이기도 하다

### 레거시 코드

레거시 시스템을 파악할 때 리팩터링이 굉장히 도움된다  
대규모 레거시 시스템을 테스트 코드 없이 명료하게 리팩터링하려면 테스트 보강이라는 단순 노동이 필요하다(쉽게 해결할 방법은 없다)

[레거시 코드 활용 전략](https://www.yes24.com/Product/Goods/64586851)을 참고하는 것도 좋다  
책의 주요 내용은 "프로그램에서 테스트를 추가할 틈새를 찾아서 시스템을 테스트해야 한다"이다

테스트를 갖추고 있더라도 쉽지 않지만, 관련된 부분끼리 나눠서 하나씩 공략해나는 것이 좋다  
레거시 시스템의 규모가 크다면 자주 보는 부분을 더 많이 리팩터링 한다  
코드를 훑게 되는 횟수가 많다는 말은 그 부분을 이해하기 쉽게 개선했을 때 얻는 효과도 그만큼 크다는 뜻이다

### 데이터베이스

데이터베이스는 리팩터링하기 어려운 영역이었지만, **진화형 데이터베이스 설계**(evolutionary database design)와 **데이터베이스 리팩터링** 개념이 널리 적용되고 있다  
이 기법의 핵심은 커다란 변경들은 쉽게 조합하고 다룰 수 있는 데이터 마이그레이션 스크립트를 작성하고, 접근 코드와 데이터베이스 스키마에 대한 구조적 변경을 이 스크립트로 처리하게끔 통합하는 데 있다

데이터베이스 리팩터링은 프로덕션 환경에 여러 단계로 나눠서 릴리즈하는 것이 좋다는 점에서 다른 리팩터링과 다르다

- 필드 이름 바꾸기 예시
  1. 새로운 데이터베이스 필드를 추가만 하고 사용하지는 않는다.
  2. 기존 필드와 새 필드를 동시에 업데이트하도록 설정한다.
  3. 데이터베이스를 읽는 클라이언트들을 새 필드를 사용하는 버전으로 조금씩 교체한다.
  4. 더는 필요 없어진 예전 필드를 삭제한다.

> 병렬 수정(parallel change) 또는 팽창 수축(expand-contract)의 일반적인 예다.

---

## 2.6 리팩터링, 아키텍처, 애그니(YAGNI)

리팩터링은 기존 소프트웨어 아키텍처를 바라보는 관점을 완전히 바꿔놓았다  
수년 동안 운영되던 소프트웨어라도 아키텍처를 대폭 변경할 수 있고, 설계를 개선할 수 있다

> 리팩터링이 아키텍처에 미치는 실질적인 효과: 요구사항 변화에 자연스럽게 대응하도록 코드베이스를 잘 설계해준다

유연성 메커니즘(flexibility mechanism)이라는 것이 있다  
범용적으로 사용할 수 있는 함수를 정의했을 때, 다양한 시나리오에 대응하기 위한 매개변수가 바로 유연성 메커니즘이다  
유연성 메커니즘은 잘못 구현할 때 비용이 발생할 수 있다 즉, 오히려 변화에 대응하는 능력을 떨어뜨릴 때가 많다

리팩터링을 이용하면 미래를 추측하지 않고, 그저 현재까지 파악한 요구사항만을 '멋지게' 해결한다  
진행하면서 사용자의 요구사항을 더 잘 이해하게 되면 다시 리팩터링한다  
그 과정에서 소프트웨어의 복잡도에 지장을 주지 않는 매커니즘은 마음껏 추가하지만, 복잡도를 높일 수 잇는 유연성 메커니즘은 반드시 검증을 거친 후에 추가한다  
호출하는 측에서 항상 같은 값을 넘기는 매개변수는 매개변수 목록에 넣지 않는다(매개변수를 추가해야 할 상황이 오면 **함수 매개변수화하기**로 해결한다)

이러한 해결 방법을 간결한 설계(simple design), 점진적 설계(incremental design), YAGNI("You aren't going to need it")라고 부른다

> 익스트림 프로그래밍의 원칙 중 하나로 '당장에 필요한 기능만으로 최대한 간결하게 만들라'라는 뜻이다.  
> 실제로도, 앞으로 필요할 것 같아서 미리 구현해둔 기능 상당수가 결국 전혀 쓰이지 않거나, 미래의 요구사항을 제대로 반영하지 못하여 오히려 수정하기 더 어려워지는 경우가 있다

YAGNI를 받아들인다고 해서 선제적인 아키텍처에 완전히 소홀해도 된다는 뜻은 아니며, 균형을 맞출 필요가 있다는 뜻이다

나중에 문제를 더 깊이 이해하게 됐을 때 처리하는 쪽이 훨씬 나을 수 있다  
이러한 경향은 진화형 아키텍처(evolutionary architecture)원칙이 발전하는 계기가 됐다

> 진화형 아키텍처는 아키텍처 관련 결정을 시간을 두고 반복해 내릴 수 있다는 장점을 활용하는 패턴과 실천법을 추구한다

---

## 2.7 리팩터링과 소프트웨어 개발 프로세스

- 익스트림 프로그래밍(`XP`)의 두드러진 특징
  - 지속적 통합
  - 자가 테스트 코드
  - 리팩터링
- 개성이 강하면서 상호 의존하는 기법들을 하나로 묶은 프로세스

> 자가 테스트 코드와 리팩터링을 묶어서 테스트 주도 개발(`TDD`, Test-Driven Development)이라 한다.

애자일(애자일 사고)를 제대로 적용하려면 리팩터링에 대한 팀의 역량과 열정이 뒷받침되어 프로세스 전반에 리팩터링이 자연스럽게 스며들도록 해야 한다

자가 테스트 코드 > 지속적 통합 > 리팩터링의 관계가 토대로 되어야 한다

이 실천법을 적용하면 YAGNI 설계 방식으로 개발을 진행할 수 있다

> 리팩터링 <-> YAGNI

리팩터링과 YAGNI는 서로 긍정적인 영향을 준다 즉, 리팩터링(과 선수 조건들)이 YAGNI의 토대인 동시에, YAGNI로 인해 리팩터링을 더욱 쉽게 할 수 있다  
위 핵심 실천법을 통해 애자일의 다른 요소까지 취할 수 있다

지속적 배포는 소프트웨어를 언제든 릴리스할 수 있는 상태로 유지해준다  
기술적인 제약보다는 비즈니스 요구에 맞춰 릴리스 일정을 계획할 수 있다

> 물론 어떠한 접근법이든지 충분한 연습과 실력이 뒷받침 되어야 한다

---

## 2.8 리팩터링과 성능

리팩터링하면 성능이 낮아질 수 있지만, 그와 동시에 성능을 튜닝하기는 더 쉬워진다  
하드 리얼타임(hard real-time) 시스템을 제외한 소프트웨어를 빠르게 만드는 비결은, 먼저 튜닝하기 쉽게 만들고 나서 원하는 속도가 나게끔 튜닝하는 것이다

빠른 소프트웨어를 작성하는 방법 세 가지

1. 시간 예산 분배(time budgeting, 엄격한 시간 분배)

- 하드 리얼타임에서 많이 사용한다
- 설계를 여러 컴포넌트로 나눠서 컴포넌트마다 자원(시간과 공간) 예산을 할당한다
- 컴포넌트는 할당된 자원 예산을 초과할 수 없다
  > 주어진 자원을 서로 주고받는 메커니즘을 제공할 수는 있다
- 엄격한 시간 엄수를 강조한다

2. 끊임없이 관심을 기울이는 것

- 프로그래머라면 누구나 높은 성능을 유지하기 위하지만, 성능을 개선하기 위해 프로그램이 더 어려워지고, 개발이 더뎌진다
- 소프트웨어가 더 빨라지면 충분한 보상을 얻겠지만 그렇지 않다
- 성능을 개선하기 위한 최적화가 프로그램 전반에 퍼지게 되는데, 각각의 개선은 프로그램의 특정 동작에만 관련될 뿐, 정작 컴파일러와 런타임과 하드웨어의 동작을 제대로 이해하지 못한 채 작성할 때가 많다

> "아무것도 안 만드는 데도 시간이 걸린다", - 론 제프리 -

시스템에 대해서 잘 알더라도 섣불리 추측하지 말고 성능을 측정해봐야 한다

대부분의 프로그램은 전체 코드 중 극히 일부에서 대부분의 시간을 소비하기 때문에 코드 전체를 최적화하더라도 그중 90%의 시간은 낭비가 된다  
즉, 의도적으로 성능 최적화에 돌입하기 전까지는 성능에 신경 쓰지 않고 코드를 다루기 쉽게 만드는데 집중한다  
성능 최적화 단계가 되면 다음의 구체적인 절차를 따라 프로그램을 튜닝한다

- 성능 최적화 단계
  1. 프로파일러로 프로그램을 분석하여 시간과 공간을 많이 잡아먹는 지점을 알아낸다
  2. 전체를 고르게 최적화할 때와 마찬가지로 그 부분들을 개선한다
  3. 사용자가 만족하는 성능에 도달할 때가지 최적화 대상을 찾아서 제거하는 일을 계속한다

- 프로그램을 잘 리팩터링해두면 최적화에 도움되는 두 가지 면
  1. 기능 추가가 빨리 끝나서 성능에 집중
  2. 리팩터링이 잘 되어 있는 프로그램은 성능을 더 세밀하게 분석 가능

> 리팩터링은 성능 좋은 소프트웨어를 만드는 데 기여한다  
> 단기적으로 보면 리팩터링 단계에서 성능이 느려질 수도 있지만 최적화 단계에서 코드를 튜닝하기 훨씬 쉬어지기 때문에 결국 더 빠른 소프트웨어를 얻게 된다

---

## 2.9 리팩터링의 유래

리팩터링이란 용어의 정확한 유래는 찾을 수 없다  
과거에는 리팩터링이 그다지 중요한 주제는 아니었지만 갈수록 그 선한 영향력으로 인해 주류 개발 기법으로 자리 잡았다

---

## 2.10 리팩터링 자동화

자동 리팩터링이 발전하고 있지만 완성도는 개발 도구마다 제법 차이가 난다  
원인은 도구 자체에 있기도 하고, 언어마다 리팩터링을 자동화할 수 있는 범위가 다르기 때문이기도 하다

리팩터링을 자동화하는 가장 어설픈 방법은 소스 코드의 텍스트를 직접 조작하는 것이다  
자동 리팩터링을 제대로 구현하려면 구문 트리로 해석해서 다뤄야 한다  
`IDE`는 리팩터링 뿐만 아니라 코드 탐색과 린팅(linting, 정적 분석)을 비롯한 다양한 기능을 구현하는 데 구문 트리를 활용한다

그러나 단순히 구문 트리를 해석해서 수정하는 것만으로는 리팩터링을 구현할 수 없다  
변경된 구문 트리를 다시 에디터 화면에 텍스트로 바꿔 표현해야 한다

텍스트 에디터보다 `IDE`가 이런 리팩터링의 디테일에서 훨씬 강력하기 때문에 프로그래밍 효율 면에서 훨씬 유리하다

하지만 이러한 자동 리팩터링에는 실수가 있을 수 있기 때문에 반드시 테스트로 확인해야 한다

> 최근에는 텍스트 에디터도 사용할 수 있는 언어 서버(Language Server)라는 기술이 뜨고 있다  
> 언어 서버란 구문 트리를 구성해서 텍스트 에디터에 `API` 형태로 제공하는 소프트웨어다

---

## 2.11 더 알고 싶다면

- [리팩터링 워크북] - 윌리엄 웨이크(William C. Wake)
- [패턴을 활용한 리팩터링] - 조슈아 케리에브스키(Joshua Kerievsky)
- [리팩터링 데이터베이스] - 스콧 앰블러(Scott W. Ambler), 프라모드 사달게(Pramod Sadalage)
- [리팩터링 HTML] - 엘리엇 러스티 해롤드(Elliotte Rusty Harold)
- [레거시 코드 활용 전략] - 마이클 페더스(Michael Feathers)
- [Refactoring: Ruby Edition] - 제이 필즈(Jay Fields), 셰인 하비(Shane Harvey)
- [Github - Refactoring](https://github.com/WegraLee/Refactoring)
- [Refactoring Website](https://refactoring.com)