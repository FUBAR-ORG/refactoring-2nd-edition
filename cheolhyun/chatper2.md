# Chapter 02 - 리팩터링 원칙

## 2.1 리팩터링 정의

**리팩터링**은 두리뭉실한 의미로 통용되며, 명사로도 쓰일 수 있고 동사로도 쓰일 수 있다

> 리팩터링: [명사] 소프트웨어의 겉보기 동작은 그대로 유지한 채, 코드를 이해하고 수정하기 쉽도록 내부 구조를 변경하는 기법
> > 함수 추출하기, 조건부 로직을 다형성으로 바꾸기

> 리팩터링: [동사] 소프트트웨어의 겉보기 동작은 그대로 유지한 채, 여러가지 리팩터링 기법을 적용해서 소프트웨어를 재구성하다.

특정한 방식에 따라 코드를 정리하는 것만이 리팩터링이다  
리팩터링은 결국 동작을 보존하는 작은 단계들을 거쳐 코드를 수정하고, 이러한 단계들을 순차적으로 연결하여 큰 변화를 만들어내는 일이다  
따라서 리팩터링하는 동안에는 코드가 항상 정상 작동하기 때문에 전체 작업이 끝나지 않았더라도 언제든 멈출 수 있다

> 누군가 "리팩터링하다가 코드가 깨져서 며칠이나 고생했다"라고 한다면, 십중팔구 리팩터링한 것이 아니다.

코드베이스를 정리하거나 구조를 바꾸는 모든 작업을 **재구성(restructuring)**이라는 포괄적인 용어로 표현하고, 리팩터링은 재구성의 한 형태

리팩터링은 겉보기 동작을 동일하게 유지하기 때문에 내부적인 성능의 변화는 있을 수 있고, 모듈의 인터페이스가 변경될 수도 있다  
리팩터링 과정 중 발견된 버그는 리팩터링 후에도 남아 있어야 한다(아무도 모르는 숨은 버그는 수정해도 괜찮다)

리팩터링은 성능 최적화와 유사하게 코드를 변경하지만 프로그램의 전반적인 기능은 그대로 유지한다  
단지 목적이 다를 뿐이다

> 성능 최적화는 프로그램의 특정 부분을 더 빠르게 만드는 것이 목적이다  
> 목표 성능에 반드시 도달해야 한다면 코드는 다루기 더 어려워질 수 있음을 각오해야 한다

---

## 2.2 두 개의 모자

소프트웨어를 개발할 때 목적이 '기능 추가'냐, 아니면 '리팩터링'이냐를 명확히 구분해 작업한다  
이 두 가지 목적을 동시에 수행하면 안된다  
기능 추가에서는 테스트를 작성하여 통과하는지 확인만 하고 리팩터링에서는 기능 추가를 하지 않고, 동시에 테스트도 추가하지 않는다  
부득이하게 인터페이스를 변경해야 할 때만 기존 테스트를 수정한다

항상 내가 어떤 작업을 하고 있는지와 그에 따른 미묘한 작업 방식의 차이를 분명하게 인식해야 한다

---

## 2.3 리팩터링하는 이유

### 리팩터링하면 소프트웨어 설계가 좋아진다

리팩터링하지 않으면 소프트웨어의 내부 설계(아키텍처)가 썩기 쉽다  
아키텍처를 이해하지 못한 채 단기 목표만을 위해 코드를 수정하다 보면 기반 구조가 무너지기 쉽다  
그렇게 코드만 봐서는 설계를 파악하기 어려워진다

> 규칙적인 리팩터링은 코드의 구조를 지탱해줄 것이다

중복 코드 제거는 설계 개선 작업의 중요한 한 축을 차지한다  
코드량이 줄어들면 수정하는 데 드는 노력은 크게 달라진다  
이해해야할 코드량도 줄어들고 실수 없이 수정하기 쉬워지며 동작을 예상하기 쉽다

> 중복 코드를 제거하면 모든 코드가 언제나 고유한 일을 수행함을 보장할 수 있으며, 이는 바람직한 설계의 핵심

### 리팩터링하면 소프트웨어를 이해하기 쉬워진다

프로그래밍은 컴퓨터와 대화하는 것과 유사하지만, 내 소스 코드를 컴퓨터만 사용하는 것이 아니다  
몇 달이 지나 누군가 내 코드를 수정하고자 읽을 대, 코드를 이해하기 어렵다면 시간에 지연이 발생할 것이다

프로그램을 동작시키는 데만 신경 쓰다 보면 나중에 그 코드를 다룰 개발자를 배려하지 못한다는 데 있다  
코드를 이해하기 쉽게 만들려면 일하는 리듬에 변화를 줘야 한다

리팩터링은 코드가 더 잘 읽히게 도와준다

다른 사람이 곧 내가 될 수 있기 때문에 리팩터링은 더더욱 중요하다

기억할 필요가 있는 것들은 최대한 코드에 담으려 한다

### 리팩터링하면 버그를 쉽게 찾을 수 있다

코드를 이해하기 쉽다는 말은 버그를 찾기 쉽다는 말이기도 하다  
리팩터링 과정에 "이럴 것이다"라고 가정하던 점들이 분명히 드러나는데, 버그를 지나치려야 지나칠 수 없을 정도까지 명확해진다

> "난 뛰어난 프로그래머가 아니에요. 단지 뛰어난 습관을 지닌 괜찮은 프로그래머일 뿐이에요."

### 리팩터링하면 프로그래밍 속도를 높일 수 있다

새로운 기능을 추가할수록 기존 코드베이스에 잘 녹여낼 방법을 찾는 데 드는 시간이 늘어난다

프로그래밍 속도는 소프트웨어 내부 품질에 따라 달라질 수 있다  
내부 설계가 잘 된 소프트웨어는 새로운 기능을 추가할 지점과 어떻게 고칠지를 쉽게 찾을 수 있다

모듈화가 잘 되어 있으면 전체 코드베이스 중 작은 일부만 이해하면 된다  
코드가 명확하면 버그를 만들 가능성도 줄고, 버그를 만들더라도 디버깅하기가 훨씬 쉽다

내부 품질이 뛰어난 코드베이스는 새 기능 구축을 돕는 견고한 토대가 된다

#### 지구력 가설(Design stamina Hypothesis)

내부 설계에 심혈을 기울이면 소프트웨어의 지구력이 높아져서 빠르게 개발할 수 있는 상태를 더 오래 지속할 수 있다

> 처음부터 좋은 설계를 마련하기란 매우 어렵다  
> 그래서 빠른 개발이라는 숭고한 목표를 달성하려면 리팩터링이 반드시 필요하다

---

## 2.4 언제 리팩터링해야 할까?

> 필자는 프로그래밍할 때 거의 한 시간 간격으로 리팩터링 한다

### 3의 법칙(돈 로버츠, Don Roberts)

1. 처음에는 그냥 한다.
2. 비슷한 일을 두 번째로 하게 되면(중복이 생겼다는 사실에 당황스럽겠지만), 일단 계속 진행한다.
3. 비슷한 일을 세 번째 하게 되면 리팩터링한다.

> 스트라이크 세 번이면 리팩터링(삼진 리팩터링)

### 준비를 위한 리팩터링: 기능을 쉽게 추가하게 만들기

리팩터링하기 가장 좋은 시점은 코드베이스에 기능을 새로 추가하기 직전이다  
이 시점에서 현재 코드를 살펴보면서, 구조를 살짝 바꾸면 다른 작업을 하기가 훨씬 쉬워질 만한 부분을 찾는다

- 기존의 함수가 새로운 요구사항을 거의 만족하지만 리터럴 값 몇 개가 방해되는 함수가 있다
- 함수를 복제해서 해당 값만 수정해도 되지만 중복 코드가 발생한다
  - 나중에 이 부분을 변경할 일이 생기면 원래 코드가 복사한 코드를 모두 수정해야 한다
  - 더 심한 경우는 복제한 코드가 어디 있는지까지 일일이 찾아내야 한다
  - 나중에 새 기능을 약간 변형한 버전을 만들어야 할 때 번거로울 수 있다
- 이럴 때 **함수 매개변수화하기**를 적용할 수 있다

> 다들 "직진!"이라고 외칠 때 "잠깐, 지도를 보고 가장 빠른 경로를 찾아보자"라고 말할 줄 아는 것이 준비를 위한 리팩터링이다

버그를 잡을 때도 마찬가지이다

오류를 일으키는 코드가 세 곳에 복제되어 퍼져 있다면, 우선 한 곳으로 합치는 편이 작업하기에 훨씬 편하다  
또는 질의 코드에 섞여 있는 갱신 로직을 분리하면 두 작업이 꼬여서 생기는 오류를 크게 줄일 수 있다

> 준비를 위한 리팩터링(Preparatory Refactoring)으로 상황을 개선해놓으면 버그가 수정된 상태가 오래 지속될 가능성을 높이는 동시에, 같은 곳에서 다른 버그가 발생할 가능성을 줄일 수도 있다

### 이해를 위한 리팩터링: 코드를 이해하기 쉽게 만들기

코드를 수정하려면 먼저 그 코드가 하는 일을 파악해야 한다  
코드를 파악할 때마다 그 코드의 의도가 더 명확하게 드러나도록 리팩터링할 여지는 없는지 찾아본다

리팩터링하면 머리로 이해한 것을 코드에 옮겨담을 수 있고, 수정한 코드를 테스트해보면 내 생각이 맞았는지 확인할 수 있다

코드를 분석할 때 리팩터링을 해보면, 그렇지 않았더라면 도달하지 못했을 더 깊은 수준까지 이해하게 된다

### 쓰레기 줍기 리팩터링

리팩터링의 필요가 있는 코드를 봤을 때 급한 일에 의해서 당장 처리를 못하더라도 조금이나마 개선해두는 것이 좋다

> 항상 처음 봤을 때보다 깔끔하게 정리하고 떠나자.

### 계획된 리팩터링과 수시로 하는 리팩터링

앞선 리팩터링은 모두 기회가 될 때만 진행한다  
리팩터링 일정을 따로 잡아두지 않고, 기능을 추가하거나 버그를 잡는 동안 리팩터링도 함께 한다 즉, 프로그래밍 과정에 자연스럽게 녹인 것이다

리팩터링은 프로그래밍과 구분되는 별개의 활동이 아니다  
마치 프로그래밍할 때 `if` 문 작성 시간을 따로 구분하지 않는 것과 같다

> 보기 싫은 코드를 발견하면 리팩터링하자. 그런데 잘 작성된 코드 역시 수많은 리팩터링을 거쳐야 한다.

> 무언가 수정하려 할 때는 먼저 수정하기 쉽게 정돈하고 쉽게 수정하자.

리팩터링에 소홀했다면, 따로 시간을 내서 새 기능을 추가하기 쉽도록 코드베이스를 개선할 필요가 있다

계획된 리팩터링은 예상치 못한 상황에 대응하기 어렵기 때문에 최소한으로 줄여야 한다

### 오래 걸리는 리팩터링

리팩터링의 규모가 커질 수 있지만 이 경우에도 팀 전체가 리팩터링에 매달리는 것은 좋지 않은 것 같다  
주어진 문제를 몇 주에 걸쳐 조금씩 해결해가는 편이 효과적일 때가 많다

- 라이브러리를 교체할 때는 기존 것과 새 것 모두를 포용하는 추상 인터페이스부터 마련한다
- 기존 코드가 이 추상 인터페이스를 호출하도록 만들고 나면 라이브러리를 훨씬 쉽게 고칠 수 있다
- > 이 전략을 추상화로 갈아타기(Branch By Abstraction)라 한다

### 코드 리뷰에 리팩터링 활용하기

코드 리뷰는 개발팀 전체에 지식을 전파하는 데 좋다

- 노하우 전수
- 대규모 소프트웨어 시스템의 다양한 측면을 더 많은 사람이 이해
- 깔끔한 코드 작성
- 다른 사람의 아이디어 전달

리팩터링은 다른 이의 코드를 리뷰하는 데도 도움된다

리팩터링은 코드 리뷰의 결과를 더 구체적으로 도출하는 데에도 도움된다  
개선안들을 제시하는 데서 그치지 않고, 그중 상당수를 즉시 구현해볼 수 있기 때문이다

풀 리퀘스트 모델은 코드 리뷰에 리팩터링을 접목하는 방법에는 그리 효과적이지 않다  
코드 작성자가 참석해야 맥락을 설명해줄 수 있고 작성자도 리뷰어의 변경 의도를 제대로 이해할 수 있으므로, 이왕이면 참석자가 참석하는 방식이 좋다

> 작성자와 나란히 앉아서 코드를 훑어가며 리팩터링하면 자연스럽게 짝 프로그래밍(pair programming)이 된다

### 관리자에게는 뭐라고 말해야 할까?

- 프로 개발자의 역할: 효과적인 소프트웨어를 최대한 빨리 만드는 것이다
- 프로 개발자에게 주어진 임무: 새로운 기능을 빠르게 구현하는 것이고, 가장 빠른 방법은 리팩터링이다

그래서 리팩터링부터 한다

### 리팩터링하지 말아야 할 때

1. 지저분한 코드를 발견해도 굳이 수정할 필요가 없다면 리팩터링하지 않는다  
   외부 `API` 다루듯 호출해서 쓰는 코드라면 지저분해도 그냥 둔다  
   내부 동작을 이해해야 할 시점에 리팩터링해야 효과를 제대로 볼 수 있다
2. 리팩터링하는 것보다 처음부터 새로 작성하는 게 쉬울 때도 리팩터링하지 않는다

---

## 2.5 리팩터링 시 고려해야 할 문제

무언가 언제 어디에 적용할지 판단하려면 손익을 제대로 이해해야 한다

리팩터링에 딸려 오는 문제도 엄연히 있기에, 이런 문제가 언제 발생하고 어떻게 대처해야 할지를 반드시 알고 있어야 한다

### 새 기능 개발 속도 저하

> 리팩터링의 궁극적인 목적은 개발 속도를 높여서, 더 적은 노력으로 더 많은 가치를 창출하는 것이다

그렇더라도 상황에 맞게 조율해야 한다

대부분은 리팩터링을 더 자주 하도록 노력해야 한다  
리더는 리팩터링의 필요성과 리팩터링 상황 판단 능력을 빠르게 갖추도록 개발 과정에서 많이 이끌어줘야 한다

리팩터링을 클린 코드(clean code)나 바람직한 엔지니어링 습관처럼 도덕적인 이유로 정당화하는 것이 가장 쉽게 빠지기 쉬운 오류이다  
리팩터링의 본질은 코드베이스를 예쁘게 꾸미는 것이 아니라, 경제적인 이유로 하는 것이다

### 코드 소유권

리팩터링하다 보면 모듈의 내부뿐 아니라 시스템의 다른 부분과 연동하는 방식에도 영향을 주는 경우가 많다  
리팩터링이 영향을 주는 코드의 소유자가 다른 팀이라서 쓰기 권한이 없을 수도 있다

리팩터링을 할 수 없는 것은 아니기 때문에, 기존 함수도 그대로 유지하며 기존 함수를 폐기 대상(deprecated)으로 표시한다

코드 소유권을 작은 단위로 나눠 엄격히 관리하면 오히려 인터페이스를 관리하느라 시달리는 결과를 초래할 수 있다

> 대규모 시스템에서는 오픈소스 개발 모델을 권장하기도 한다

### 브랜치

현재 가장 대중적으로 사용하는 [`Git Flow`](https://tecoble.techcourse.co.kr/post/2021-07-15-git-branch/)와 같은 전략은 독립 브랜치로 작업하는 기간이 길어질수록 `master` 브랜치로 통합하기 어려워진다는 단점이 있다  
그 고통을 줄이고자 마스터를 개인 브랜치에 수시로 리베이스하거나 머지한다  
하지만 여러 기능 브랜치에서 동시에 개발이 진행될 때는 이런 식으로 해결할 수 없다

머지와 통합을 명확히 구분한다

- 마스터를 브랜치로 머지하는 작업: 단방향
- 통합(마스터를 개인 브랜치로 풀 -> 작업한 결과를 다시 마스터에 푸시): 양방향

누군가 개인 브랜치에서 작업한 내용을 마스터에 통합하기 전까지는 그 내용을 볼 수 없다  
통합한 뒤에는 마스터에서 달라진 내용을 내 브랜치에서 머지해야 하는데, 그러려면 상당한 노력이 들 수 있다

이에 기능별 브랜치의 통합 주기를 2~3일 단위로 짧게 관리해야 한다고 주장하는 **지속적 통합**(`CI`, Continuous Integration)
, 또는 **트렁크 기반 개발**(`TBD`, Trunk-Based Development)이라 한다

`CI`에 따르면 모든 팀원이 하루에 최소 한 번은 마스터와 통합한다

- `CI`를 적용하기 위해서 치러야 할 대가
  - 마스터를 건강하게 유지
  - 거대한 기능을 잘게 쪼개는 법
  - 각 기능을 끌 수 있는 기능 토글(기능 플래그) 적용

`CI`는 리팩터링과 궁합이 아주 좋다  
리팩터링은 코드 전반적인 수정을 가할 때가 많으므로 머지 과정에서 충돌이 생길 위험이 크다

`CI`와 리팩터링을 합쳐서 **익스트림 프로그래밍**(`XP`, eXtreme Programming) 기법이 탄생했다

> 기능별 브랜치를 사용하지 말자는 것이 아니라, 브랜치를 자주 통합하여 문제가 발생할 가능성을 줄인다는 것이다  
> 통합 주기만큼은 최대한 짧게 잡아야 한다

> `CI`를 적용하는 편이 소프트웨어를 배포하는 데 훨씬 효과적이라는 객관적인 증거가 있다

### 테스팅

리팩터링의 단위 핵심은 오류를 재빨리 잡는 데 있으며, 이렇게 하려면 코드의 다양한 측면을 검사하는 테스트 스위트(test suite)가 필요하다  
달리 말하면 리팩터링하기 위해서는 자가 테스트 코드(self-testing code)를 마련해야 한다는 뜻이다

자가 테스트 코드는 리팩터링을 할 수 있게 해줄 뿐만 아니라, 새 기능 추가의 안정성을 높여준다  
테스트가 실패한다면 가장 최근에 통과한 버전에서 무엇이 달라졌는지 살펴볼 수 있다

자가 테스트 코드는 통합 과정에서 발생하는 의미 충돌을 잡는 메커니즘으로 활용할 수 있어서 자연스럽게 `CI`와도 밀접하게 연관된다  
`CI`에 통합된 테스트는 `XP`의 권장사항이자 지속적 배포(`CD`, Continuous Delivery)의 핵심이기도 하다

### 레거시 코드

레거시 시스템을 파악할 때 리팩터링이 굉장히 도움된다  
대규모 레거시 시스템을 테스트 코드 없이 명료하게 리팩터링하려면 테스트 보강이라는 단순 노동이 필요하다(쉽게 해결할 방법은 없다)

[레거시 코드 활용 전략](https://www.yes24.com/Product/Goods/64586851)을 참고하는 것도 좋다  
책의 주요 내용은 "프로그램에서 테스트를 추가할 틈새를 찾아서 시스템을 테스트해야 한다"이다

테스트를 갖추고 있더라도 쉽지 않지만, 관련된 부분끼리 나눠서 하나씩 공략해나는 것이 좋다  
레거시 시스템의 규모가 크다면 자주 보는 부분을 더 많이 리팩터링 한다  
코드를 훑게 되는 횟수가 많다는 말은 그 부분을 이해하기 쉽게 개선했을 때 얻는 효과도 그만큼 크다는 뜻이다

### 데이터베이스

데이터베이스는 리팩터링하기 어려운 영역이었지만, **진화형 데이터베이스 설계**(evolutionary database design)와 **데이터베이스 리팩터링** 개념이 널리 적용되고 있다  
이 기법의 핵심은 커다란 변경들은 쉽게 조합하고 다룰 수 있는 데이터 마이그레이션 스크립트를 작성하고, 접근 코드와 데이터베이스 스키마에 대한 구조적 변경을 이 스크립트로 처리하게끔 통합하는 데 있다

데이터베이스 리팩터링은 프로덕션 환경에 여러 단계로 나눠서 릴리즈하는 것이 좋다는 점에서 다른 리팩터링과 다르다

> 병렬 수정(parallel change) 또는 팽창 수축(expand-contract)의 일반적인 예다.