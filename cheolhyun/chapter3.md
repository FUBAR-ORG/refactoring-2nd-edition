# Chapter 03 - 코드에서 나는 악취

- 리팩터링을 언제 시작하고 언제 그만할지 판단하는 일은 리팩터링의 작동 원리를 아는 것 못지 않게 중요하다
- 리팩터링할 '시점'을 설명하기에 '냄새'라는 표현을 사용해볼 수 있다
- 인스턴스 변수의 갯수, 메서드의 줄 수 등은 경험을 통해 감을 키워야 한다

## 3.1 기이한 이름(Mysterious Name)

- 코드는 반드시 단순하고 명료하게 작성해야 하며, 그를 이루기 위한 중요한 요소로 '이름'이 있다
- 함수, 모듈, 변수, 클래스 등은 그 이름만 보고도 무슨 일을 하고 어떻게 사용하는지 알 수 있어야 한다
- 컴퓨터 과학에서 가장 어려운건 캐시 무효화와 이름 짓기라고 할 만큼 어렵고, 그로 인해 많은 리팩터링 기법이 존재한다
    - 함수 언언 바꾸기, 변수 이름 바구기, 필드 이름 바꾸기
- 이름만 잘 지어도 나중에 문맥을 파악하느라 헤매는 시간을 크게 절약할 수 있다

> 마땅한 이름이 떠오르지 않는 경우, 설계에 근본적인 문제가 숨어 있을 가능성이 있다

---

## 3.2 중복 코드(Duplicated Code)

- 한 클래스에 딸린 두 메서드가 똑같은 표현식을 사용하는 경우
    - 함수 추출하기
- 코드가 비슷하긴 한데 완전 똑같지는 않은 경우
    - 문장 슬라이스하기 -> 함수 추출하기
- 같은 부모로부터 파생된 서브 클래스들에 코드가 중복되어 있는 경우
    - 메서드 올리기

---

## 3.3 긴 함수(Long Function)

- 짧은 함수는 간접 호출(indirection)의 효과를 일으킬 수 있다
    - 코드를 이해하고, 공유하고, 선택하기 쉬워진다
- 예전 언어는 서브루틴을 호출하는 비용이 컸기 때문에 짧은 함수를 꺼렸으나, 요즘 언어는 프로세스 안에서의 함수 호출 비용을 거의 없애버렸다
- 짧은 함수로 구성된 코드를 이해하기 쉽게 만드는 가장 확실한 방법: **좋은 이름**
    - 그러기 위해서는 적극적으로 함수를 쪼개야 한다
- 주석을 달아야 하는 부분은 무조건 함수로 만든다
    - 함수에는 주석으로 설명하려던 코드가 담기고, 함수 이름은 **동작 방식이 아닌 의도**(intention)이 드러나게 짓는다

> 핵심: 함수의 길이가 아닌, 함수의 목적(의도)과 구현 코드의 괴리가 얼마나 큰가
> - '무엇을 하는지'를 코드가 잘 설명해주지 못할수록 함수로 만드는게 유리

- 함수를 짧게 만드는 대부분의 기법
    - 함수 추출하기
- 매개변수와 임시 변수의 수가 늘어났을 경우
    - 임시 변수를 질의 함수로 바꾸기
    - 매개변수 객체 만들기, 객체 통째로 넘기기
- 임시 변수가 여전히 많을 경우
    - 함수를 명령으로 바꾸기
- 조건문
    - 조건문 분해하기
    - `switch` 문의 경우 각 `case` 문마다 함수 추출하기를 적용
- 같은 조건을 기준으로 나뉘는 `switch` 문이 여러 개일 경우
    - 조건부 로직을 다형성으로 바꾸기
- 반복문
    - 그 안에 코드와 함께 추출하여 독립된 함수로 만들기
    - 반복문 쪼개기

---

## 3.4 긴 매개변수 목록(Long Parameter List)

- 초기에는 전역 데이터를 막기 위해 매개변수로 많은 것을 전달함
- 하지만, 매개변수의 목록이 길어지면 그 자체로 이해하기 어려울 때가 많음
- 다른 매개변수에서 값을 얻어올 수 있는 매개변수
    - 매개변수를 질의 함수로 바꾸기
- 사용 중인 데이터 구조에서 값들을 뽑아 각각을 별개의 매개변수로 전달하는 코드
    - 객체 통째로 넘기기
- 항상 함께 전달되는 매개변수
    - 매개변수 객체 만들기
- 함수의 동작 방식을 정하는 플래그
    - 플래그 인수 제거하기
- 여러 함수를 클래스로 묶기를 이용하여 공통 값들을 클래스 필드로 정의 가능
    - 함수형 프로그래밍에서는 일련의 부분 적용 함수(partially applied function)들을 생성

---

## 3.5 전역 데이터(Global Data)

> 전역 데이터는 코드베이스 어디에서든 건드릴 수 있고 값을 누가 바꿨는지 찾아낼 메커니즘이 없는 문제가 있다  
> 클래스 변수와 싱글톤에서도 같은 문제가 발생할 수 있다

- 변수 캡슐화하기를 사용할 수 있다
- 다른 코드에서 오염시킬 가능성이 있는 데이터를 발견할 때마다 이 기법을 가장 먼저 적용한다
    - 더 나아가 접근자 함수들을 클래스나 모듈에 집어넣고 그 안에서만 사용할 수 있도록 접근 범위를 최소로 줄이는 것도 좋다

> 전역 데이터는 아주 조금만 있더라도 캡슐화 할 필요가 있다

---

## 3.6 가변 데이터(Mutable Data)

- 함수형 프로그래밍에서는 가변 데이터의 위험성을 알고 데이터를 변경하지 않는다
- 가변성을 제공하는 프로그래밍 언어가 더 많기 때문에 무분별한 데이터 수정의 위험을 제거해야 한다
    - 변수 캡슐화 하기
- 하나의 변수에 용도가 다른 값들을 저장하느라 값을 갱신하는 경우
    - 변수 쪼개기
- 갱신 로직은 다른 코드와 떨어뜨려 놓는 것이 좋다
    - 문장 슬라이스 하기, 함수 추출하기
- `API`를 만들 때
    - 질의 함수와 변경 함수 분리하기
- 가능한 세터 제거하기도 적용한다
- 가변 데이터가 풍기는 악취가 고약할 때
    - 파생 변수를 질의 함수로 바꾸기
- 변수의 유효 범위가 넓을 경우
    - 여러 함수를 클래스로 묶기, 여러 함수를 변환 함수로 묶기
- 구조체처럼 내부 필드에 데이터를 담고 있는 변수
    - 참조를 값으로 바꾸기

---

## 3.7 뒤엉킨 변경(Divergent Change)

- 코드를 쉉할 때 시스템에서 고쳐야 할 딱 한 군데를 찾아서 고칠 수 없는 경우
    - **뒤엉킨 변경**과 **산탄총 수술**의 냄새가 풍긴다
- 뒤엉킨 변경은 단일 책임 원칙(`SRP`)이 제대로 지켜지지 않았을 때 나타남
- 순차적으로 실행되는게 자연스러운 맥락일 경우
    - 단계 쪼개기: 다음 맥락에 필요한 데이터를 특정한 데이터 구조에 담아 전달
- 전체 처리 과정 곳곳에서 각기 다른 맥락의 함수를 호출하는 빈도가 높은 경우
    - 함수 옮기기: 각 맥락에 해당하는 적당한 모듈을 만들어서 관련 함수들을 모음
- 여러 맥락의 일에 관여하는 함수가 있는 경우
    - 함수 추출하기
    - 모듈이 클래스일 경우 클래스 추출하기

---

## 3.8 산탄총 수술(Shotgun Surgery)

> 뒤엉킨 변경과 비슷하면서 정반대

- 코드를 변경할 때마다 자잘하게 수정해야 하는 클래스가 많을 때 풍긴다
- 함께 변경되는 대상들을 함수 옮기기와 필드 옮기기로 묶어둠
- 비슷한 데이터를 다루는 함수가 많은 경우
    - 여러 함수를 클래스로 묶기
- 데이터 구조를 변환하거나 보강하는 함수
    - 여러 함수를 변환 함수로 묶기
- 묶은 함수들의 출력 결과를 묶어서 다음 단계의 로직으로 전달할 수 있다면
    - 단계 쪼개기
- 어설프게 분리된 로직을 함수 인라인하기나 클래스 인라인하기 같은 인라인 리팩터링으로 하나로 합치는 것도 좋은 대처 방안

> 사실 우리는 작은 함수와 클래스에 지나칠 정도로 집착하지만, 코드를 재구성하는 중간 과정에서는 큰 덩어리로 뭉쳐지는데 개의치 않는다.

---

## 3.9 기능 편애(Feature Envy)

> 기능 편애: 흔히 어떤 함수가 자기가 속한 모듈의 함수나 데이터보다 다른 모듈의 함수나 데이터와 상호작용 할 일이 더 많을 때 풍기는 냄새

> 프로그램을 모듈화할 때는 코드를 여러 영역으로 나눈 뒤 영역 안에서 이뤄지는 상호작용은 최대한 늘리고 영역 사이에서 이뤄지는 상호작용은 최소로 줄이는 데 주력

- 실행 과정에서 외부 객체의 게터 메서드 대여섯개를 호출하도록 작성된 함수
    - 함수 옮기기: 함수가 데이터와 가까이 있고 싶어 한다는 의중이 뚜렷이 드러나므로
- 함수의 일부에서만 기능을 편애할 경우
    - 함수 추출하기 -> 함수 옮기기
- 어디로 옮길지가 명확하게 드러나지 않을 때
    - 함수 추출하기: 함수를 여러 조각으로 나눈 후 각각을 적합한 모듈로 옮김
        - 가장 많은 데이터를 포함한 모듈로 옮긴다

> 전략 패턴(Strategy Pattern)과 방문자 패턴(Visitor Pattern)은 위의 규칙을 거스르는 복잡한 패턴  
> 켄트 백의 자기 위임(Self-Delegation)도 여기에 속함
>
> 이들은 모두 뒤엉킨 변경 냄새를 없앨 때 활용하는 패턴  
> 기본 원칙: 함께 변경할 대상을 한데 모으는 것

---

## 3.10 데이터 뭉치(Data Clumps)

- 필드 형태의 데이터 뭉치
    - 클래스 추출하기
- 메서드 시그니처에 있는 데이터 뭉치
    - 매개변수 객체 만들기, 객체 통째로 넘기기

> 데이터 뭉치 판별법: 값 하나를 삭제해본다  
> 나머지 데이터만으로 의미가 없다면, 데이터 뭉치

- 레코드 구조가 아닌 클래스 구조를 이용하면 좋은 향기를 흩뿌릴 기회가 생긴다
- 기능 편애를 없애는 과정에서 새로운 클래스를 만들었다면, 그 클래스로 옮기면 좋은 동작은 없는지 살펴 볼 필요가 있다

---

## 3.11 기본형 집착(Primitive Obsession)

- 주어진 문제에 딱 맞는 기초 타입을 직접 정의하기 몹시 꺼리는 사람이 많다
    - 특히 문자열에서 자주 발생한다
- 이런 자료형을 문자열로만 표현하는 악취는 아주 흔해서, 소위 '문자열화된(stringly typed)' 변수라는 용어가 생겼다
- 기본형을 객체로 바꾸기를 적용할 수 있다
- 기본형으로 표현된 코드가 조건부 동작을 제어하는 타입 코드(type code)로 쓰였을 경우
    - 타입 코드를 서브 클래스로 바꾸기 -> 조건부 로직을 다형성으로 바꾸기
- 자주 함께 몰려다니는 기본형 그룹도 데이터 뭉치
    - 클래스 추출하기, 매개변수 객체 만들기

---

## 3.12 반복되는 `switch`문(Repeated Switches)

- 객체 지향 신봉작들은 `switch` 문과 `if` 문의 사악함을 알고 대부분 휴지통에 담아야 한다고 주장했다
- 조건문은 사악하지만 지금의 `switch` 문은 복잡한 타입까지 분기에 지원하기 때문에, `switch` 자체는 발생할 수 있다
- 다만, 똑같은 조건부 로직이 여러 곳에서 반복해 등장하는 코드에 집중해야 한다

> 중복된 `switch` 문이 문제가 되는 이유는 조건절을 하나 추가할 때마다 다른 `switch` 문들도 모두 찾아서 함께 수정해야 하기 때문이다.

---

## 3.13 반복문(Loops)

- 지금은 일급 함수(first-class function)을 지원하는 언어가 많아졌다
    - 반복문을 파이프랑니응로 바꾸기

---

## 3.14 성의 없는 요소(Lazy Element)

> 프로그램의 요소: 프로그래밍 언어가 제공하는 함수(메서드), 클래스, 인터페이스 등 코드 구조 활용 요소

- 프로그램 요소가 불필요하게 적용되어 있으면, 사정이 어떠하든 제거할 필요가 있다
    - 함수 인라인하기, 클래스 인라인하기
    - 상속의 경우 계층 합치기

---

## 3.15 추측성 일반화(Speculative Genarality)

> 추측성 일반화: '나중에 필요할거야'라는 생각으로 당장은 필요 없는 모든 종류의 후킹(hooking) 포인트와 특이 케이스 처리 로직을 작성해둔 코드

- 당장 걸리적거리는 코드는 눈 앞에서 치워버려야 한다
- 하는 일이 거의 없는 추상 클래스
    - 계층 합치기
- 쓸데 없이 위임하는 코드
    - 함수 인라인하기, 클래스 인라인하기
- 본문에서 사용하지 않는 매개변수
    - 함수 선언 바꾸기
- 추측성 일반화는 테스트 코드 말고 사용하는 곳이 없는 함수나 클래스에서 흔히 볼 수 있음
    - 테스트 케이스부터 삭제한 뒤에 죽은 코드 제거하기

---

## 3.16 임시 필드(Temporary Field)

> 임시 필드: 특정 상황에서만 값이 설정되는 필드

- 덩그러니 떨어져 있는 필드들을 발견
    - 클래스 추출하기 -> 함수 옮기기
- 임시 필드들이 유효한지를 확인한 후 동작하는 조건부 로직
    - 특이 케이스 추가하기

---

## 3.17 메시지 체인(Message Chains)

> 메시지 체인: 클라이언트가 한 객체를 통해 다른 객체를 얻은 뒤 방금 얻은 객체에 또 다른 객체를 요청하는 방식  
> 다른 객체를 요청하는 작업이 연쇄적으로 이어지는 코드  
> 이는 클라이언트가 객체 내비게이션 구조에 종속되었음을 의미

- 위임 숨기기로 해결
    - 메시지 체인의 다양한 연결점에 적용 가능
        - 모든 체인에 적용하면 중간 객체들이 모두 중개자가 될 수 있음
- 최종 결과 객체가 어떻게 쓰이는지 살펴본다
    - 함수 추출하기로 결과 객체를 사용하는 코드 일부 추출 후 함수 옮기기로 체인을 숨길 수 있는지

```javascript
managerName = aPerson.department.manager.name;

managerName = aPerson.department.managerName; // 관리자 객체(manager)의 존재를 숨김
managerName = aPerson.manager.name; // 부서 객체(department)의 존재를 숨김
managerName = aPerson.managerName; // 부서 객체와 관리자 객체 모두의 존재를 숨김
```

---

## 3.18 중개자(Middle Man)

> 중개자: 객체의 대표적인 기능 중 하나로, 외부로부터 세부사항을 숨겨주는 캡슐화(encapsulation)가 있다.  
> 캡슐화하는 과정에서는 위임(delegation)이 자주 활용된다

- 위임이 지나친 경우(클래스가 제공하는 메서드 중 절반이 다른 클래스에 구현을 위임)
    - 중개자 제거하기
- 제거 후 남는 일이 거의 없는 경우
    - 함수 인라인하기

---

## 3.19 내부자 거래(Insider Trading)

- 모듈 사이에 데이터 거래가 많으면 결합도(coupling)가 높아진다
    - 일이 돌아가게 하려면 거래가 이뤄질 수 밖에 없지만, 그 양을 최소로 줄이고 모두 투명하게 처리해야 한다
- 은밀히 데이터를 주고 받는 모듈들이 있는 경우
    - 함수 옮기기, 필드 옮기기
- 여러 모듈이 같은 관심사를 공유하는 경우
    - 제 3의 모듈 만들기, 위임 숨기기(중간자)
- 자식 클래스가 부모의 품을 떠나야 할 때가 왔을 경우
    - 서브 클래스를 위임으로 바꾸기, 슈퍼 클래스를 위임으로 바꾸기

---

## 3.20 거대한 클래스(Large Class)

- 한 클래스가 너무 많은 일을 하는 경우
    - 클래스 추출하기: 필드 일부를 따로 묶음
        - 같은 컴포넌트에 모아두는 것인 합당해 보이는 필드들을 선택
        - 한 클래스 안에서 접두어나 접미어가 같은 필드
- 분리할 컴포넌트들을 원래 클래스와 상속 관계로 만드는 게 좋을 경우
    - 슈퍼 클래스 추출하기, 타입 코드를 서브 클래스로 바꾸기
- 큰 클래스의 가장 간단한 해법: 자체적으로 중복을 제거하는 것
- 클라이언트들이 거대 클래스를 이용하는 패턴을 파악하여 쪼갤 단서를 찾을 수 있다
    - 클래스 추출하기, 슈퍼 클래스 추출하기, 타입 코드를 서브 클래스로 바꾸기

> 여러 클래스로 분리한다

---

## 3.21 서로 다른 인터페이스의 대안 클래스들(Alternative Classes with Different Interfaces)

- 클래스의 장점은 다른 클래스로 언제든 교체할 수 있다는 것
    - 교체하려면 인터페이스가 같아야 한다
    - 함수 선언 바꾸기로 메서드 시그니처를 일치시킨다
    - 함수 옮기기를 이용하여 인터페이스가 같아질 때까지 필요한 동작들을 클래스 안으로 밀어 넣는다
- 대안 클래스들 사이에 중복 코드가 생기는 경우
    - 슈퍼 클래스 추출하기를 적용할지 고려한다

---

## 3.22 데이터 클래스(Data Class)

> 데이터 클래스: 데이터 필드와 `Getter`/`Setter`만 있는 클래스

- 이런 클래스에 `public` 필드가 있는 경우
    - 레코드 캡슐화하기, 세터 제거하기
- 다른 클래스에서 데이터 클래스의 게터나 세터를 사용하는 경우
    - 함수 옮기기, 함수 추출하기
- 데이터 클래스는 필요한 동작이 엉뚱한 곳에 정의되어 있다는 신호
    - 클라이언트 코드를 데이터 클래스로 이동
    - 예외: 다른 함수를 호출해 얻은 결과로는 동작 코드를 넣을 이유가 없다
        - Example) 단계 쪼개기의 결과로 나온 중간 데이터 구조
            - 이런 데이터 구조는 불변(immutable)

---

## 3.23 상속 포기(Refused Bequest)

- 부모의 유산을 원치 않거나 필요 없는 경우
    - 예전에는 계층 구조를 잘못 설계하는 경우로 인식함
        - 이 관점에서 해법
            - 같은 계층에 서브 클래스 생성
            - 메서드 내리기, 필드 내리기

> 상속 포기 냄새: 서브 클래스가 부모의 동작은 필요로하지만 인터페이스는 따르고 싶지 않을 때 심하게 난다.

- 서브 클래스를 위임으로 바꾸기, 슈퍼 클래스를 위임으로 바꾸기를 활용해서 **상속 메커니즘**에서 벗어나보자

---

## 3.24 주석(Comments)

- 주석은 악취가 아닌 향기
    - 주석을 탈취제처럼 사용하는 것은 문제
- 주석이 장황하게 달린 원인이 코드를 잘못 작성했기 때문인 경우가 잦다
- 특정 코드 블록이 하는 일에 주석을 남기고 싶은 경우
    - 함수 추출하기
- 여전히 설명이 필요하다면
    - 함수 선언 바꾸기
- 시스템이 동작하기 위한 선행조건을 명시하고 싶다면
    - 어서션 추가하기

> 주석을 남겨야겠다는 생각이 들면, 가장 먼저 주석이 필요 없는 코드로 리팩터링해본다.

- 뭘 할지 모를 때라면 주석을 달아두면 좋다
    - 현재 진행 상황 뿐만 아니라 확실하지 않은 부분에 주석을 남긴다
    - 코드를 지금처럼 작성한 이유를 설명하는 용도로 달 수도 있다
    - 이런 정보는 나중에 코드를 수정해야 할 프로그래머에게, 특히 건망증이 심한 프로그래머에게 도움이 될 것이다